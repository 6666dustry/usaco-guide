---
id: dp-sos
title: Sum over Subsets DP
author: Rameez Parwez, Siyong Huang, Aakash Gokhale
description: Taking bitmask DP to the next level.
prerequisites:
  - dp-bitmasks
frequency: 2
redirects:
  - /adv/dp-sos
---

<Resources>
	<Resource
		source="CF"
		title="SOS Dynamic Programming [Tutorial]"
		url="45223"
		starred
	>
		Good explanation + problem list
	</Resource>
	<Resource
		source="GFG"
		title="Sum over Subsets | Dynamic Programming"
		url="sum-subsets-dynamic-programming/"
	>
		Goes over brute force solutions
	</Resource>
	<Resource
		source="CF"
		title="Some SOS DP Insights"
		url="105247"
		starred
	>
		Characterizing SOS DP as multidimensional prefix sums
	</Resource>
</Resources>

Sum Over Subsets (SOS) is technique used to efficiently calculate the sum of values for all subsets of a given set or bitmask. Instead of manually generating every subset, which can be slow, SOS uses bitwise operations to quickly go through only the necessary subsets.

The main trick is that for any bitmask $x$, we can directly loop through all its subsets $i$ using:

$$
i = (i - 1)\&x
$$

This ensures we efficiently handle only the subsets of $x$, skipping unnecessary combinations.

## Implementation

Consider an array $A$ of $2^n$ elements. For a bitmask $x$, we define $F(x)$ as the sum of $A[i]$ over all subset mask $i \subseteq x$. That is:

$$
F(x) = \sum_{i \subseteq x} A[i]
$$

The goal is to compute $F(x)$ for all $x = 0, 1, 2, ...., 2^n - 1$ as efficiently as possible.

## Solution

### Brute Force

The naive solution is to iterate over all pair of masks, summing $A[i]$ only when one of them is a subset of the other (i.e.,$i \& x = i$).

<LanguageSection>
<CPPSection>

```cpp
vector<int> sos(1 << n);

for (int x = 0; x < (1 << n); x++) {
    // iterate over all other sets and checks whether they're a subset of x
    for (int i = 0; i < (1 << n); i++) {
        if ((i & x) == i) {
            sos[x] += a[i];
        }
    }
}
```

</CPPSection>
<PySection>

```py
sos = [0] * (1 << n)
for x in range(1 << n):
	# iterate over all other sets and checks whether they're a subset of x
	for i in range(1 << n):
		if (x &i) == i:
			sos[x] += a[i]
```

</PySection>
</LanguageSection>

This solution has a time complexity of $\mathcal{O}(2^n \cdot 2^n) = O(4^n)$, which is too slow for large values of $n$.

### Optimized Solution : Iterating Over Submasks

Instead of iterating over all $2^n$ bitmasks for $i$, we can optimize by iterating only over the subset mask of $x$.

<LanguageSection>
<CPPSection>

```cpp
vector<int> sos(1 << n);

for (int x = 0; x < (1 << n); x++) {
	sos[x] = a[0];
	// iterate over all subsets of x directly
	for (int i = x; i > 0; i = (i - 1) & x) {
		sos[x] += a[i];
	}
}
```

</CPPSection>
<PySection>

```py
sos = [0] * (1 << n)
for x in range(1 << n):
	sos[x] = a[0]
	i = x
	# iterate over all subsets of x directly
	while i > 0:
		sos[x] += a[i]
		i = (i - 1) & x
```

</PySection>
</LanguageSection>

<Spoiler title="How does this works?">
If you subtract $1$ from a bitmask $i$, the rightmost $1$-bit becomes $0$, and all bits to the right of it become $1$. Performing bitwise _AND_ with $x$ ensures that only the bits within $x$ are retained. By starting with $i = x$ and repeatedly applying $(i - 1) \& x$, all subset masks of $x$ are visited in reverse order.

The operation $(i - 1) \& x$ ensures that each new value of $i$ is strictly smaller than the previous one and is also a valid submask of $x$. There is no need to explicitly check $(i \& x) == i$.

Example: Consider $x = 10110$ and $n = 5$.

The submask of $x$ are $\{00000, 00010, 00100, 00110, 10000, 10010, 10100, 10110\}$. The second loop will generate these submasks in reverse order.

Initial state: $i = x = 10110$

First iteration:
- $i = 10110$
- Subtract $1: 10110 - 1 = 10101$
- Bitwise _AND_ with $x: 10101 \& 10110 = 10100$
- Next $i = 10100$

Second iteration:
- $i = 10100$
- Subtract $1: 10100 - 1 = 10011$
- Bitwise _AND_ with $x: 10011 \& 10110 = 10010$
- Next $i = 10010$

Third iteration:
- $i = 10010$
- Subtract $1: 10010 - 1 = 10001$
- Bitwise _AND_ with $x: 10001 \& 10110 = 10000$
- Next $i = 10000$

Repeating this process generates the remaining submasks in reverse order until $i = 0$.

</Spoiler>

**Time Complexity:** $ \mathcal{O}(3^n)$

<Spoiler title="Proof">

The number of subset masks for a bitmask of size $k$(i.e., $k$ set bits) is $2^k$. There are $n \choose k$ bitmasks with $k$ set bits. Thus, the total number of operations is:

$$
\sum^n_{k = 0}{n \choose k} \cdot 2^k = (1 + 2)^n = 3^n
$$

</Spoiler>

### Faster Solution using Dynamic Programming

While the previous method is better, it still has some redundancy. For example, if a bitmask $i$ has $k$ unset bits, then $A[i]$ is summed $2^k$ times. If we precompute and reuse these sums, we can eliminate repeated additions.

#### Subset Mask Partitioning with $S(x, i)$

We define the subset $S(x, i)$ as follows:

$$
S(x, i) = \{y \subseteq x \mid y \oplus x < 2^{i + 1}\}
$$

In simpler terms, $S(x, i)$ contains all subset masks of $x$ whose bits to the left of the $i$-th bit match those of $x$.

For example:
$$
S(11010110, 3) = \{11010000,11010010,11010100,11010110\}
$$

We can break $S(x, i)$ as follows:

1.  If the $i$-th bit of $x$ is $0$, then $S(x, i) = S(x, i - 1)$.
2.  If the $i$-th bit of $x$ is $1$:
    - Subsets with the $i$-th bit $1: S(x, i - 1)$.
    - Subsets with the $i$-th bit $0 : S(x \oplus 2^i, i - 1)$.
Thus:
$$
S(x, i) =
\begin{cases}
S(x, i - 1) & \text{if the i-th bit is 0} \\
S(x, i - 1) \cup S(x \oplus 2^i, i - 1) & \text{if the i-th bit is 1}
\end{cases}
$$

Using the above partitioning, we define a DP table $dp[x][i]$ where:
$$
dp[x][i] = \sum_{y \in S(x, i)} A[y]
$$

**Time Complexity:** $\mathcal{O}(N \cdot 2^N)$

<LanguageSection>
<CPPSection>

```cpp
vector<int> sos(1 << n);
vector<vector<int>> dp(1 << n, vector<int> (n));

for (int x = 0; x < (1 << n); x++) {
	dp[x][0] = a[x];
	if (x & 1) {
		dp[x][0] += a[x ^ 1];
	}
	for (int i = 1; i < n; i++) {
		dp[x][i] = dp[x][i - 1];
		if (x & (1 << i)) {
			dp[x][i] += dp[x ^ (1 << i)][i - 1];
		}
	}
	sos[x] = dp[x][n - 1];
}
```

</CPPSection>
<PySection>

```py
sos = [0] * (1 << n)
dp = [[0] * n for _ in range(1 << n)]

for x in range(1 << n):
	dp[x][0] = a[x]
	if x & 1:
		dp[x][0] += a[x ^ 1]

	for i in range(1, n):
		dp[x][i] = dp[x][i - 1]
		if x & (1 << i):
			dp[x][i] += dp[x ^ (1 << i)][i - 1]

	sos[x] = dp[x][n - 1]
```

</PySection>
</LanguageSection>

#### Optimized Memory Usage

Since $dp[x][i]$ only depends on $dp[x][i - 1]$, we can reuse the DP array.

<LanguageSection>
<CPPSection>

```cpp
for (int i = 0; i < (1 << n); i++) {
	sos[i] = a[i];
}

for (int i = 0; i < n; i++) {
	for (int x = 0; x < (1 << n); x++) {
		if (x & (1 << i)) {
			sos[x] += sos[x ^ (1 << i)];
		}
	}
}
```

</CPPSection>
<PySection>

```py
sos = [0] * (1 << n)
for i in range(1 << n):
	sos[i] = a[i]

for i in range(n):
	for x in range(1 << n):
    		if x & (1 << i):
			sos[x] += sos[x ^ (1 << i)]
```

</PySection>
</LanguageSection>

### SOS DP as N-Dimensional Prefix Sum

To understand this, let's revisit $2D$ prefix sums. Given $n \times m$ array $A$, the prefix sum array $S$ is defined as:

$$
S[i][j] = \sum_{a \leq i} \sum_{b \leq j} A[a][b]
$$

The standard approach uses inclusion-exlcusion:

$$
S[i][j] = S[i][j - 1] + S[i - 1][j] - S[i - 1][j - 1] + A[i][j]
$$

However, this approach has a drawback: as the number of dimensions grows, the number of terms we need to add or subtract grows exponentially. A simple and more scalable approach is to sweep through each dimensions one at a time and compute the prefix sum step by step:

<LanguageSection>
<CPPSection>

```cpp
// Initialize
for (int i = 0; i < n; i++) {
    	for (int j = 0; j < m; j++) {
        	S[i][j] = A[i][j];
	}
}

// Sweep along x-axis
for (int i = 1; i < n; i++) {
    	for (int j = 0; j < m; j++) {
        	S[i][j] += S[i - 1][j];
	}
}

// Sweep along y-axis
for (int i = 0; i < n; i++) {
    	for (int j = 1; j < m; j++) {
        	S[i][j] += S[i][j - 1];
	}
}
```

</CPPSection>
<PySection>

```py
# Initialize
for i in range(n):
    	for j in range(m):
        	S[i][j] = A[i][j]

# Sweep along the x-axis
for i in range(1, n):
    	for j in range(m):
        	S[i][j] += S[i - 1][j]

# Sweep along the y-axis
for i in range(n):
    	for j in range(1, m):
        	S[i][j] += S[i][j - 1]
```

</PySection>
</LanguageSection>

This approach generalizes to higher dimensions. For example, in $4D$:

- After sweeping along the x-axis, $S[i][j][k][l]$ contains the sum of $A[a][b][c][d]$ where $a \leq i, b = j, c = k,$ and $d = l$.
- After sweeping along the y-axis, $S[i][j][k][l]$ contains the sum of $A[a][b][c][d]$ where $a \leq i, b \leq j, c = k,$ and $d = l$.
- After sweeping along the z-axis, $S[i][j][k][l]$ contains the sum of $A[a][b][c][d]$ where $a \leq i, b \leq j, c \leq k,$ and $d = l$.
- After sweeping along the w-axis, $S[i][j][k][l]$ contains the sum of $A[a][b][c][d]$ where $a \leq i, b \leq j, c \leq k,$ and $d \leq l$.

If we extend this idea to $n$ dimensions, here's what happens: after sweeping along the $i$-th axis, $S[x]$ contains the sum of $A$ values where the first $i$ coordinates are less than or equal to $x$, and the remaining coordinates match $x$. Sound familiar? That's exactly what $F(x)$ represents in the SOS problem!

If we think of each bit in a bitmask as its own axis, then a bitmask $x$ with $n$ bits can be viewed as an $n$-dimensional coordinate where each component is either $0$ or $1$. A submask of $x$ corresponds to an $n$-dimensional coordinate where each component is less than or equal to $x$. Therefore, when we interpret the bitmask as an $n$-dimensional coordinate, $F(x)$ alings with the definition of an $n$-dimensional prefix sum!

By applying the sweeping algorithm along each axis, we get the memory-optimized SOS DP solution mentioned earlier, demonstrating that SOS DP is indeed an **n-dimensional prefix sum**.

<LanguageSection>
<CPPSection>

```cpp
for (int i = 0; i < (1 << n); i++) {
    	F[i] = A[i];
}

for (int i = 0; i < n; i++) {  // Sweep along the i-th axis
    	for (int x = 0; x < (1 << n); x++) {
        	if (x & (1 << i))  // If the i-th bit is set, accumulate
            	F[x] += F[x ^ (1 << i)];
    	}
}
```

</CPPSection>
<PySection>

```py
for i in range(1 << n):
	F[i] = A[i]

for i in range(n): # Sweep along the i-th axis
	for x in range(1 << n):
		if x & (1 << i): # If the i-th bit is set, accumulate
			F[x] += F[x ^ (1 << i)]
```

</PySection>
</LanguageSection>

## General Problems

<Problems problems="probs" />

---
id: dp-sos
title: Sum over Subsets DP
author: Siyong Huang, Aakash Gokhale
description: Taking bitmask DP to the next level.
prerequisites:
  - dp-bitmasks
frequency: 2
redirects:
  - /adv/dp-sos
---

<Resources>
	<Resource
		source="CF"
		title="SOS Dynamic Programming [Tutorial]"
		url="45223"
		starred
	>
		Good explanation + problem list
	</Resource>
	<Resource
		source="GFG"
		title="Sum over Subsets | Dynamic Programming"
		url="sum-subsets-dynamic-programming/"
	>
		Goes over brute force solutions
	</Resource>
	<Resource
		source="CF"
		title="Some SOS DP Insights"
		url="105247"
		starred
	>
		Characterizing SOS DP as multidimensional prefix sums
	</Resource>
</Resources>


Sum Over Subsets (SOS) is technique used to efficiently calculate the sum of values for all subsets of a given set or bitmask. Instead of manually generating every subset, which can be slow, SOS uses bitwise operations to quickly go through only the necessary subsets.

The main trick is that for any bitmask $i$, we can directly loop through all its subsets $j$ using:

$$
j = (j - 1)\&i
$$

This ensures we efficiently handle only the subsets of $i$, skipping unnecessary combinations.

## Implementation

Consider an array $A$ of $2^n$ elements. For a bitmask x, we define $F(x)$ as the sum of $A[i]$ over all subset mask $i \subseteq x$. That is:

$$
F(x) = \sum_{i \subseteq x} A[i] 
$$

The goal is to compute $F(x)$ for all $x = 0, 1, 2, ...., 2^n - 1$.

## Brute Force 

The naive solution is to iterate over all pair of masks, summing $A[i]$ only when one of them is a subset of the other (i.e.,$i \& x = i$).

<LanguageSection>
<CPPSection>

```cpp
vector<int> arr(1 << n);
vector<int> sos(1 << n);

for (int x = 0; x < (1 << n); x++) {
    //iterate over all other sets and checks whether they're a subset of x
    for (int i = 0; i < (1 << n); i++) {
        if ((i & x) == i) {
            sos[x] += arr[i];
        }
    }
}
```
</CPPSection>
</LanguageSection>

This solution has a time complexity of $\mathcal{O}(2^n \cdot 2^n) = O(4^n)$, which is impractical for large $n$.


We can speed this up if we iterate over only subsets of the current mask and add up all of the those values to get the sum over subsets for a particular mask.

The difference comes from the fact that in the first example we iterate over every pair of subsets which takes $(2^n)^2$ time and the second we iterate directly over the subsets for each mask. This means each mask is only visited by $2^{n - k}$ other masks where k is the number of elements of the mask.
This means that the total time complexity is $\mathcal{O} (\sum_0^n {n \choose k} \cdot 2^{n - k} = 3^n)$.

<LanguageSection>
<CPPSection>

```cpp
int n = 20;
vector<int> a(1 << n);
vector<int> sos(1 << n);
for (int i = 0; i < (1 << n); i++) {
	sos[i] = a[0];
	// iterate over all subsets of i directly
	for (int j = i; j > 0; j = (j - 1) & i) {
		sos[i] += a[j];
	}
}
```

</CPPSection>
</LanguageSection>

Notice how in both of these examples we don't seem to be saving much information between different subsets which is the essence of DP.
Define $\texttt{SOS}(\texttt{mask}, x)$ to be the sum of subsets of mask such that the first $x$ bits of the subset are identical to the first $x$ bits of mask.
For example, $\texttt{SOS}(1001001, 3)$ includes the subsets $1001001$, $1000001$, $1001000$, $1000000$ which all have the same common prefix of $100$.

Let's try to figure out the transitions between different states.

If the $x$th bit of mask is a $0$ then we can only transition to this state if the $x$th bit of the subset is also $0$. If the $x$th bit of the subset mask was a $1$ then it would no longer be a subset.

If the $x$th bit of mask is a $1$ then we can transition to this state from both subsets where the $x$th bit is turned off and turned on because both of these cases would be subsets.

More formally,

$\texttt{SOS}(mask, x) = \left\{
	\begin{array}{ c l }
		\texttt{SOS}(\texttt{mask}, x - 1) + \texttt{SOS}(\texttt{mask} - 2^x, x - 1) & \quad \textrm{if } |2^x \& \texttt{mask}| > 0 \\
		\texttt{SOS}(\texttt{mask}, x - 1) & \quad \textrm{otherwise}
	\end{array}
\right.$


<LanguageSection>
<CPPSection>

```cpp
int n = 20;
vector<int> a(1 << n);

// keeps track of the sum over subsets
// with a certain amount of matching bits in the prefix
vector<vector<int>> dp(1 << n, vector<int>(n));

vector<int> sos(1 << n);
for (int mask = 0; mask < (1 << n); mask++) {
	dp[mask][-1] = a[mask];
	for (int x = 0; x < n; x++) {
		if (mask & (1 << x)) {
			dp[mask][x] = dp[mask][x - 1] + dp[mask ^ (1 << x)][x - 1];
		}
		else {
			dp[mask][x] = dp[mask][x - 1];
		}
	}
	sos[mask] = dp[mask][n - 1];
}
```

</CPPSection>
</LanguageSection>

## Additional Problems

<Problems problems="probs" />

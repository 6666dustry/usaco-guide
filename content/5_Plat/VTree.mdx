---
id: VT
title: Virtual Tree
author: Ryan Fu
prerequisites:
description: Compressing a tree to only necessary nodes
---

<Resources>
	<Resource
		source="YouTube"
		title="CP Tutorial: Virtual/Auxiliary Tree"
		url="https://www.youtube.com/watch?v=czySm7bUHgY"
	>
	</Resource>
	<Resource
		source="CF"
		title="Virtual trees method"
		url="https://codeforces.com/blog/entry/140066"
	>
	</Resource>
	<Resource
		source="OIWiki"
		title="OIWiki - Virtual Tree"
		url="https://oi-wiki.org/graph/virtual-tree/"
	>
	</Resource>
	<Resource
		source="YKW"
		title="YouKn0wWho Academy - Virtual Tree / Auxiliary Tree"
		url="https://youkn0wwho.academy/topic-list/virtual_tree"
	>
	</Resource>

</Resources>

Often, when running operations or dynamic programming on trees, we only need to keep track of
a few key nodes and their relationships. If we are able to isolate the few relevant nodes that keep
the structure of the tree intact, while still maintaining the relationships between key nodes, we can
cut our time complexity down significantly.

## Example - Unique Occurences

<FocusProblem problem="uniqueocc" />

### Naive Solution

We observe that any operation will only affect nodes of the same depth. Thus, instead of solving for all depths at once, we can take the sum of the minimum cost to fill in each depth.

Consider depth $d$. Define $\texttt{dp}[v]$ as the minimum cost to fill in all vertices of depth $d$ in the subtree of $v$, only considering operations selecting vertices at $v$ or lower.

- If $v$ is of depth $d$, then we must fill it in with cost $a_0$
$$
\texttt{dp}[v] =a_0
$$
- Otherwise, we can either select to incur a cost of $a_{d-\text{depth}[v]}$ by operating on $v$, or not operate on $v$ and instead solve for each subtree:
$$
\texttt{dp}[v] = \min(a_{d-\text{depth}[v]},\sum_{u\in\text{Children}(v)} \text{dp}[u])
$$

Our answer will be the sum of $\texttt{dp}[0]$ for each value of $d$, yielding a solution in $\mathcal{O}(n^2)$ time.

### Virtual Tree Optimization

One observation we can make is for a long chain ending at $v$, we can process it quickly by taking

$$
\texttt{dp}[v] = \min(\min_{x\in[d-\text{depth}[v],d]}a_x), \sum_{u\in\text{Children}(v)} \text{dp}[u])
$$

We will aim to leverage this fact. Define $S_0$ as the set of vertices at depth $d$. Define

$$
S = S_0 \cup \{\text{LCA}(u,v) \mid u, v \in S_0\}
$$

$S$ is the *virtual tree* or *auxiliary tree* of $S_0$. We can also define $p'_v$, the virtual parent of $v$ as the lowest node in $S$ such that $p'_v \neq v$ and $\text{LCA}(p'_v,v) = p'_v$, and $v$ as a virtual child of $p'_v$.

Here is an example of a virtual tree, with nodes in $S_0$ colored purple, and the rest of the virtual tree in blue:

![VTree](./assets/vtree_example.png)

We continue in a similar fashion to previously, but we only compute dynamic programming values for nodes in $S$. The range minimum query can be answered using data structures in logarithmic or linear time.

$$
\texttt{dp}[v] = \min(\min_{x\in[d-\text{depth}[v],d]}a_x), \sum_{u\in\text{Virtual Children}(v)} \text{dp}[u])
$$

Our time complexity will then be $\mathcal{O}( \sum_d |S|)$, because we iterate over set $S$ for each depth.

In the following section, we prove that $|S|$ is bounded by $\mathcal{O}(S_0)$, and also demonstrate how to construct a virtual tree.

### Virtual Tree Construction

A well-known method to construct the virtual tree of set $S_0$ is as follows:

- Sort the points in $S_0$ by DFS order, and add them to $S$
- Calculate the LCA of any two adjacent key points in $S_0$, and add that to $S$
- Build the virtual tree based on the ancestor-descendant relationship of the original tree

For a rough proof of correctness, consider the following:
> Observe that a vertex $v \in S$ must either satisfy $v \in S_0$ or there exist at least two distinct children of $v$ with key points in their subtrees.
>
> The former is taken care of immediately in step 1. In the latter case, as a property of DFS order, there must exist key points $a,b$ in the subtree of $v$ such that $a,b$ are in distinct subtrees and $a,b$ are adjacent in the DFS order when only considering key points. Because $v$ is $\text{LCA}(a,b)$, our construction neccesarily holds true.

A corollary of our construction is that $|S|$ is indeed bounded by $\mathcal{O}(|S_0|)$ - in fact, a tight bound is $|S| \leq 2 \cdot |S_0|-1$.

### Implementation

Below is an implementation for the task, which also contains general code for constructing virtual trees. Because $\sum_d |S|$ is $\mathcal{O(n)}$, and we sort by DFS order, our final time complexity is $\mathcal{O}(n\log n)$.

<!--
Will clean up code later :pray:
-->

```cpp
#include "bits/stdc++.h"
using namespace std;
#define all(x) begin(x), end(x)
#define sz(x) (int) (x).size()
#define int long long

const int mxn = 1e5+5;
const int LG = 17;
const int inf = 1e18;

int n,tin[mxn],tout[mxn],d[mxn],lift[mxn][LG],timer,dp[mxn];
vector<int> g[mxn],vg[mxn],atd[mxn];

void dfs(int v, int p) {
	d[v] = v ? d[p]+1 : 0;
	atd[d[v]].push_back(v);
	tin[v] = timer++;
	
	lift[v][0] = p;
	for (int i=1; i<LG; i++)
		lift[v][i] = lift[lift[v][i-1]][i-1];
	
	for (int u : g[v]) {
		if (u==p) continue;
		dfs(u,v);
	}
	tout[v] = timer++;
}

inline int is_ancestor(int u, int v) {
	return tin[u] <= tin[v] && tout[v] <= tout[u];
}

inline int lca(int u, int v) {
	if (is_ancestor(u,v)) return u;
	if (is_ancestor(v,u)) return v;
	for (int i=LG-1; i>=0; i--) {
		if (!is_ancestor(lift[u][i],v))
			u = lift[u][i];
	}
	return lift[u][0];
}

bool sort_tin(const int &a, const int &b) {
	return tin[a] < tin[b];
}

vector<int> vtree(vector<int> &key) {
	if (!sz(key)) return {};
	vector<int> res = key; sort(all(key),sort_tin);
	for (int i=1; i<sz(key); i++)
		res.push_back(lca(key[i-1],key[i]));
	sort(all(res),sort_tin);
	res.erase(unique(all(res)),res.end());
	for (int v : res) vg[v].clear();
	vector<int> stk = {res[0]};
	for (int i=1; i<sz(res); i++) {
		while (tin[res[i]] > tout[stk.back()])
			stk.pop_back();
		vg[stk.back()].push_back(res[i]);
		stk.push_back(res[i]);
	}
	return res;
}

namespace rmq {
	const int L = 1<<20;
	const int DEFAULT = inf;
	int seg[2*L];	
	inline void point_set(int QI, int QV) {
		QI += L; seg[QI] = QV; QI /= 2;
		while (QI) {
			seg[QI] = min(seg[2*QI],seg[2*QI+1]);
			QI /= 2;
		}
	}
	int range_query(int QL, int QR, int CL=0, int CR=L-1, int CI=1) {
		if (QL > CR || CL > QR) return DEFAULT;
		if (QL <= CL && CR <= QR) return seg[CI];
		return min(
			range_query(QL,QR,CL,(CL+CR)/2,2*CI),
			range_query(QL,QR,(CL+CR)/2+1,CR,2*CI+1)
		);
	}
}

void solve() {
	cin>>n;
	for (int i=0; i<=n; i++) {
		g[i].clear();
		atd[i].clear();
	}
	for (int i=0; i<n; i++) {
		int a; cin>>a;
		rmq::point_set(i,a);
	}
	for (int i=1; i<n; i++) {
		int u,v; cin>>u>>v; --u; --v;
		g[u].push_back(v); g[v].push_back(u);
	}
	dfs(0,0);
	int ans = 0;
	for (int dep=0; dep<n; dep++) {
		vector<int> vt = vtree(atd[dep]);
		reverse(all(vt));
		for (int v : vt) {
			dp[v] = rmq::range_query(dep-d[v],dep);
			if (sz(vg[v])) {
				int su = 0;
				for (int u : vg[v])
					su += dp[u];
				dp[v] = min(dp[v],su);
			}
		}
		if (sz(vt))
			ans += dp[vt[sz(vt)-1]];
	}
	cout<<ans<<"\n";
}

signed main() {
	ios::sync_with_stdio(false); cin.tie(nullptr);
	
	int t; cin>>t;
	while (t--) solve();
	
}
```


## Problems

<Problems problems="general" />

---
id: VT
title: Virtual Tree
author: Ryan Fu
prerequisites:
description: Compressing a tree to only necessary nodes
---

<Resources>
	<Resource
		source="YouTube"
		title="CP Tutorial: Virtual/Auxiliary Tree"
		url="https://www.youtube.com/watch?v=czySm7bUHgY"
	>
	</Resource>
	<Resource
		source="CF"
		title="Virtual trees method"
		url="https://codeforces.com/blog/entry/140066"
	>
	</Resource>
	<Resource
		source="OIWiki"
		title="OIWiki - Virtual Tree"
		url="https://oi-wiki.org/graph/virtual-tree/"
	>
	</Resource>
	<Resource
		source="YKW"
		title="YouKn0wWho Academy - Virtual Tree / Auxiliary Tree"
		url="https://youkn0wwho.academy/topic-list/virtual_tree"
	>
	</Resource>

</Resources>

Often, when running operations or dynamic programming on trees, we only need to keep track of
a few key nodes and their relationships. If we are able to isolate the few relevant nodes that keep
the structure of the tree intact, while still maintaining the relationships between key nodes, we can
cut our time complexity down significantly.

## Example - Unique Occurences

<FocusProblem problem="uniqueocc" />

**Statement:** A tree with $n$ vertices has a color $1 \leq x_e \leq n$ on edge $e$. Let $f(u,v)$ be the number of colors that appear exactly once on that path from $u$ to $v$. Find the sum of $f(u,v)$ across all pairs of vertices $u,v$.

**Constraints:** $2 \leq n \leq 5\cdot 10^5$

### Naive Solution

Instead of counting $f(u,v)$ for each $u,v$, it seems more conducive to count, for each color, the number of paths that contain that color exactly once. We can count this by iterating over each color $c$, and maintaining $\text{dp}[v][0/1]$ as the number of paths up to $v$ which contain the color $c$ $0$ or $1$ times. Our transitions are as follows:

- If our the parent edge of $v$ is not color $c$, we can continue all paths from $v$ upwards, and start a new path from $v$:
$$
\texttt{dp}[p][0] \mathrel{+}= \texttt{dp}[v][0] + 1
$$
$$
\texttt{dp}[p][1] \mathrel{+}= \texttt{dp}[v][1]
$$

- If the parent edge of $v$ is color $c$, all paths that had color $c$ $0$ times will now have color $c$ $1$ time, and all paths that had color $c$ $1$ time will now be invalid. Additionally, we can start a new path from $v$:
$$
\texttt{dp}[p][1] \mathrel{+}= \texttt{dp}[v][0] + 1
$$

We can obtain our by summing paths over their highest vertex. Specifically, a path with exactly one occurence of $c$ necessarily has a highest vertex $v$, of which one branch has the occurence of $c$, and the other branch does not. Thus, our answer for a color $c$ is:
$$
\sum_{u\neq v\in\text{Children}(p)} \texttt{dp}[v][1]\cdot\texttt{dp}[u][0]+1
$$

Taking the total over all colors, we can get our answer in $\mathcal{O}(n^2)$ time.

### Virtual Tree Optimization

One observation we can make is that transitions when the parent edge of $v$ is not color $c$ are quite simple.

We will aim to leverage this fact. Define $S_0$ as the set of vertices that have parent edge of color $c$. Define

$$
S = S_0 \cup \{\text{LCA}(u,v) \mid u, v \in S_0\}
$$

$S$ is the *virtual tree* or *auxiliary tree* of $S_0$. We can also define $p'_v$, the virtual parent of $v$ as the lowest node in $S$ such that $p'_v \neq v$ and $\text{LCA}(p'_v,v) = p'_v$, and $v$ as a virtual child of $p'_v$.

Here is an example of a virtual tree, with nodes in $S_0$ colored purple, and the rest of the virtual tree in blue:

![VTree](./assets/vtree_example.png)

We continue in a similar fashion to previously, but we only compute dynamic programming values for nodes in $S$. This time, a pull-dp approach is more elegant, and our transitions are as follows, when considering node $u$ as a virtual child of $v$:

- If the parent edge of $u$ is not color $c$, we can continue the paths from $u$ onward. Additionally, we can combine paths leading up to $u$ with other paths of occurences $0$ or $1$ to add to our answer:

$$
\texttt{dp}[v][0] \mathrel{+}=\texttt{dp}[u][0]
$$
$$
\texttt{dp}[v][1] \mathrel{+}=\texttt{dp}[u][1]
$$
$$
\texttt{ans} \mathrel{+}=\texttt{dp}[u][0]\cdot \texttt{dp}[v][1] + \texttt{dp}[u][1] \cdot \texttt{dp}[v][0]
$$

- If the parent edge of $u$ is color $c$, we can only continue paths without an occurence of $c$. Additionally, paths from under node $u$ can only merge with paths that have no occurences of $c$ to contribute to our answer:

$$
\texttt{dp}[v][1] \mathrel{+}= \texttt{dp}[u][0]
$$
$$
\texttt{ans} \mathrel{+}= \texttt{dp}[u][0]\cdot \texttt{dp}[v][0]
$$

Our time complexity will then be $\mathcal{O}( \sum_c |S|)$, because we iterate over set $S$ for each color.

In the following section, we prove that $|S|$ is bounded by $\mathcal{O}(S_0)$, and also demonstrate how to construct a virtual tree.

### Virtual Tree Construction

A well-known method to construct the virtual tree of set $S_0$ is as follows:

- Sort the points in $S_0$ by DFS order, and add them to $S$
- Calculate the LCA of any two adjacent key points in $S_0$, and add that to $S$
- Build the virtual tree based on the ancestor-descendant relationship of the original tree

For a rough proof of correctness, consider the following:
> Observe that a vertex $v \in S$ must either satisfy $v \in S_0$ or there exist at least two distinct children of $v$ with key points in their subtrees.
>
> The former is taken care of immediately in step 1. In the latter case, as a property of DFS order, there must exist key points $a,b$ in the subtree of $v$ such that $a,b$ are in distinct subtrees and $a,b$ are adjacent in the DFS order when only considering key points. Because $v$ is $\text{LCA}(a,b)$, our construction neccesarily holds true.

A corollary of our construction is that $|S|$ is indeed bounded by $\mathcal{O}(|S_0|)$ - in fact, a tight bound is $|S| \leq 2 \cdot |S_0|-1$.

### Implementation

Below is an implementation for the task, which also contains general code for constructing virtual trees.
```cpp
#include <bits/stdc++.h>
using namespace std;

constexpr int MAX_N = 5e5;
constexpr int LG = ceil(log2(MAX_N));

int tin[MAX_N], tout[MAX_N], sub[MAX_N], col[MAX_N], lift[MAX_N][LG], timer;
long long dp[MAX_N][2];
vector<int> rev[MAX_N], vg[MAX_N];
vector<array<int, 2>> adj[MAX_N];

int dfs(int v, int p) {
	tin[v] = timer++;
	sub[v] = 1;

	lift[v][0] = p;
	for (int i = 1; i < LG; i++) { lift[v][i] = lift[lift[v][i - 1]][i - 1]; }

	for (const auto &[u, w] : adj[v]) {
		if (u == p) { continue; }
		sub[v] += dfs(u, v);
		rev[w].push_back(u);
		col[u] = w;
	}

	tout[v] = timer++;
	return sub[v];
}

bool is_ancestor(int u, int v) { return tin[u] <= tin[v] && tout[v] <= tout[u]; }

int lca(int u, int v) {
	if (is_ancestor(u, v)) { return u; }
	if (is_ancestor(v, u)) { return v; }
	for (int i = LG - 1; i >= 0; i--) {
		if (!is_ancestor(lift[u][i], v)) { u = lift[u][i]; }
	}

	return lift[u][0];
}

bool sort_tin(const int &a, const int &b) { return tin[a] < tin[b]; }

vector<int> vtree(vector<int> &key) {
	vector<int> res = key;
	sort(begin(key), end(key), sort_tin);
	for (int i = 1; i < key.size(); i++) { res.push_back(lca(key[i - 1], key[i])); }

	sort(begin(res), end(res), sort_tin);
	res.erase(unique(begin(res), end(res)), end(res));
	for (int v : res) { vg[v].clear(); }

	vector<int> stk = {res[0]};
	for (int i = 1; i < res.size(); i++) {
		while (tin[res[i]] > tout[stk.back()]) { stk.pop_back(); }
		vg[stk.back()].push_back(res[i]);
		stk.push_back(res[i]);
	}

	return res;
}

int main() {
	int n;
	cin >> n;
	for (int i = 0; i < n - 1; i++) {
		int u, v, x;
		cin >> u >> v >> x;
		u--, v--;
		adj[u].push_back({v, x});
		adj[v].push_back({u, x});
	}

	dfs(0, 0);

	long long ans = 0;
	for (int i = 1; i <= n; i++) {
		rev[i].push_back(0);
		vector<int> vt = vtree(rev[i]);
		reverse(begin(vt), end(vt));

		for (int v : vt) {
			dp[v][0] = sub[v];
			dp[v][1] = 0;

			for (int u : vg[v]) { dp[v][0] -= sub[u]; }

			for (int u : vg[v])
				if (col[u] == i) {
					ans += dp[u][0] * dp[v][0];
					dp[v][1] += dp[u][0];
				} else {
					ans += dp[u][0] * dp[v][1];
					ans += dp[u][1] * dp[v][0];
					dp[v][0] += dp[u][0];
					dp[v][1] += dp[u][1];
				}
		}
	}

	cout << ans << '\n';
}
```


## Problems

<Problems problems="general" />

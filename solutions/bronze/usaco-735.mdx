---
id: usaco-735
source: USACO Bronze 2017 Open
title: The Lost Cow
author: Jesse Choe, Ananth Kashyap, Brad Ma, Rameez Parwez
---

[Official Analysis (C++)](http://www.usaco.org/current/data/sol_lostcow_bronze_open17.html)

## Explanation

At each step, we check where Farmer John starts and where he's trying to go. If his path doesn't overlap with
Bessie's path, we add the distance he convers to a running total and move him to his starting position.
But if his path somehow overlaps with Bessie's, we only need to add his distance from Bessie to the total.

## Implementation

**Time Complexity:** $\mathcal{O}(\log|x - y|)$

<Spoiler title="Proof">

Let's say the distance between Farmer John and Bessie is $D = |x - y|$. In each step, Farmer John travels double the distance he traveled in the previous step: $1, 2, 4, 8, 16, \dots, 2^k$. We can see how the the distance grows exponentially.

Farmer John will find Bessie when the range of his movement includes her position. This happens when the distance he travels in a single step, $2^k$, becomes at least as large as $D$.

Mathematically, this means:
$$
2^k \geq D
$$

Taking log(base 2) on both sides:
$$
k \geq \log_2(D)
$$

Thus, the number of steps $k$ needed to find Bessie is proportional to $\log_2(D)$, and the overall time complexity is:
$$
\mathcal{O}(\log|x - y|)
$$

</Spoiler>

<LanguageSection>
<CPPSection>

```cpp
#include <fstream>
#include <iostream>

int main() {
	std::ifstream cin("lostcow.in");
	std::ofstream cout("lostcow.out");
	int x, y;
	cin >> x >> y;

	int direction = 1;
	int total_distance = 0;
	int direction_distance = 1;

	while (true) {
		if ((direction == 1 && x <= y && y <= (x + direction_distance)) ||
		    (direction == -1 && y <= x && (x - direction_distance) <= y)) {
			// found bessie
			total_distance +=
			    std::abs(y - x);  // distance to bessie from original position
			cout << total_distance << std::endl;
			break;
		} else {
			// bessie not found
			total_distance += direction_distance * 2;
			direction_distance *= 2;
			direction *= -1;  // switch directions
		}
	}
}
```

</CPPSection>
<JavaSection>

```java
import java.io.*;
import java.util.StringTokenizer;

public class theLostCow {
	public static void main(String[] args) throws IOException {
		Kattio io = new Kattio("lostcow");
		int x = io.nextInt();
		int y = io.nextInt();

		int direction = 1;
		int totalDistance = 0;
		int directionDistance = 1;

		while (true) {
			if ((direction == 1 && x <= y && y <= (x + directionDistance)) ||
			    (direction == -1 && y <= x && (x - directionDistance <= y))) {
				// found bessie
				totalDistance +=
				    Math.abs(y - x);  // distance to bessie from original position
				io.println(totalDistance);
				break;
			} else {
				// did not find bessie yet
				totalDistance += (directionDistance * 2);  // add to the distance count
				directionDistance *= 2;                    // double the distance
				direction *= -1;                           // switch directions
			}
		}

		io.close();
	}

	// CodeSnip{Kattio}
}
```

</JavaSection>
<PySection>

```py
# Take in the input data using python standard file I/O system
file_in = open("lostcow.in")
data = file_in.read().strip().split("\n")
x, y = map(int, data[0].split(" "))

# Compute the number of times Farmer John must change direction
if y > x:
	p = 0
	while (2**p) + x < y:
		p += 2
else:
	p = 1
	while x - (2**p) > y:
		p += 2

total_distance = 0

# Compute the total distance that farmer John must travel
if p == 0:
	print(1)
else:
	total_distance = 1
	for i in range(1, p):
		total_distance += (2**i) + (2 ** (i - 1))
	total_distance += (2 ** (p - 1)) + abs(x - y)

# Add the answer to the output file using python standard file I/O system
file_out = open("lostcow.out", "w")
file_out.write(str(total_distance))
file_out.close()
```

</PySection>
</LanguageSection>

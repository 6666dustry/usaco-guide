---
id: cf-2060E
source: CF
title: Graph Composition
author: Rameez Parwez
---

[Official Analysis (C++)](https://codeforces.com/blog/entry/138342)

## Explanation

The key idea is to focus on the connected components of both graphs.
First, we identify the connected components in $G$. Any edge in $F$ that connects vertices from different components in $G$ is problematic because it creates a connection that doesn't exist in $G$. These edges are "invalid" and must be removed. Counting these invalid edges gives us the first part of the solution: the number of edges we need to remove from $F$.

After removing these invalid edges, $F$ might end up with more connected components than $G$. To fix this, we need to add edges to $F$ to merge these extra components until the number of connected components in $F$ matches that in $G$. Each additional component in $F$ requires one edge addition to merge it with another component.

Finally, we calculate the minimum number of operations by adding two values:
- the number of invalid edges that need to be removed
- the number of extra connected components in $F$ that need to be merged.

This gives us the total steps needed to make $F$ match the structure of $G$.

## Implementation

**Time Complexity:** $ \mathcal{O}(n + m2 + m1 \cdot \log(m1))$

<LanguageSection>
<CPPSection>

```cpp
#include <functional>
#include <iostream>
#include <map>
#include <vector>

using std::function;
using std::map;
using std::pair;
using std::vector;

int main() {
	int test_num;
	std::cin >> test_num;
	for (int t = 0; t < test_num; t++) {
		int n, m1, m2;
		std::cin >> n >> m1 >> m2;
		vector<int> F[n], G[n];

		for (int i = 0; i < m1; i++) {
			int u, v;
			std::cin >> u >> v;
			F[--u].push_back(--v);
			F[v].push_back(u);
		}

		for (int i = 0; i < m2; i++) {
			int u, v;
			std::cin >> u >> v;
			G[--u].push_back(--v);
			G[v].push_back(u);
		}

		int f_comps = 0, g_comps = 0;
		map<pair<int, int>, int> invalid_edges;
		vector<int> component_id(n);
		vector<int> used(n);

		function<void(int)> dfs1 = [&](int node) -> void {
			used[node] = 1;
			for (int u : F[node]) {
				if (!used[u] and !invalid_edges[{node, u}]) { dfs1(u); }
			}
		};

		function<void(int, int)> dfs2 = [&](int node, int c) -> void {
			component_id[node] = c;
			used[node] = 1;
			for (int u : G[node]) {
				if (!used[u]) { dfs2(u, c); }
			}
		};

		for (int i = 0; i < n; i++) {
			if (!used[i]) {
				g_comps++;
				dfs2(i, g_comps);
			}
		}

		int invalid = 0;  // invalid edges in graph F
		for (int i = 0; i < n; i++) {
			for (int u : F[i]) {
				if (component_id[i] != component_id[u]) {
					invalid++;
					invalid_edges[{i, u}] = 1;
				}
			}
		}

		used.assign(n, 0);
		for (int i = 0; i < n; i++) {
			if (!used[i]) {
				f_comps++;
				dfs1(i);
			}
		}

		std::cout << invalid / 2 + (f_comps - g_comps) << '\n';
	}
}
```

</CPPSection>
</LanguageSection>

## Alternate Solution (Using Disjoint Sets)

## Implementation

**Time Complexity:** $\mathcal{O}(n + m1 + m2)$

<LanguageSection>
<CPPSection>

```cpp
#include <array>
#include <iostream>
#include <numeric>
#include <vector>

using std::array;
using std::cin;
using std::vector;

// BeginCodeSnip{Disjoint Sets Union}
struct DisjointSets {
	int n, connected_comps;
	vector<int> parents, sizes;

	DisjointSets(int _n) : n(_n), connected_comps(_n) {
		parents = vector<int>(n);
		iota(begin(parents), end(parents), 0);
		sizes = std::vector<int>(n, 1);
	}

	/** @return the "representative" node in x's component */
	int get(int x) {
		if (x == parents[x]) { return x; }
		return parents[x] = get(parents[x]);
	}

	/** @return whether the merge changed connectivity */
	bool unite(int x, int y) {
		int x_root = get(x);
		int y_root = get(y);

		if (x_root == y_root) { return false; }

		if (sizes[x_root] < sizes[y_root]) { std::swap(x_root, y_root); }
		sizes[x_root] += sizes[y_root];
		parents[y_root] = x_root;
		connected_comps--;

		return true;
	}

	/** @return whether x and y are in the same connected component */
	bool connected(int x, int y) { return (get(x) == get(y)); }
};
// EndCodeSnip

int main() {
	int test_num;
	cin >> test_num;
	for (int t = 0; t < test_num; t++) {
		int n, m1, m2;
		cin >> n >> m1 >> m2;
		vector<array<int, 2>> f_edges(m1);
		DisjointSets F(n), G(n);
		int res = 0;

		for (int i = 0; i < m1; i++) {
			int a, b;
			cin >> a >> b;
			f_edges[i] = {--a, --b};
		}

		for (int i = 0; i < m2; i++) {
			int a, b;
			cin >> a >> b;
			G.unite(--a, --b);
		}

		for (int i = 0; i < m1; i++) {
			if (G.connected(f_edges[i][0], f_edges[i][1])) {
				F.unite(f_edges[i][0], f_edges[i][1]);
			} else {
				res += 1;
			}
		}

		res += F.connected_comps - G.connected_comps;
		std::cout << res << '\n';
	}
}
```

</CPPSection>
</LanguageSection>

---
id: leetcode-502
source: LC
title: IPO
author: Rameez Parwez
---

## Explanation

We can solve this problem using a greedy approach by prioritizing projects that offer the highest profit while ensuring they can be started with the capital we currently have.

## Implementation

**Time Complexity:** $ \mathcal{O} (N \logN)$

<LanguageSection>
<CPPSection>

```cpp
class Solution {
  public:
	int findMaximizedCapital(int k, int w, vector<int> &profits, vector<int> &capital) {
		int n = (int)profits.size();
		vector<pair<int, int>> projects(n);
		for (int i = 0; i < n; i++) { projects[i] = {capital[i], profits[i]}; }

		sort(begin(projects), end(projects));
		priority_queue<int> pq;

		int j = 0;
		while (j < n && k > 0) {
			if (projects[j].first <= w) {
				pq.push(projects[j].second);
				j++;
			} else {
				if (pq.empty()) {
					return w;
				}
				w += pq.top();
				pq.pop();
				k -= 1;	
			}
		}

		while (k-- && !pq.empty()) {
			w += pq.top();
			pq.pop();
		}

		return w;
	}
};
```

</CPPSection>
<PySection>

```py
import heapq


class Solution:
	def findMaximizedCapital(
		self, k: int, w: int, profits: List[int], capital: List[int]
	) -> int:
		n = len(profits)
		projects = [(capital[i], profits[i]) for i in range(n)]
		projects.sort()

		j = 0
		pq = []

		while j < n and k > 0:
			if projects[j][0] <= w:
				heapq.heappush(pq, -projects[j][1])
				j += 1
			else:
				if not pq:
					return w

				w += -heapq.heappop(pq)
				k -= 1

		while k > 0 and pq:
			w += -heapq.heappop(pq)
			k -= 1

		return w
```

</PySection>
</LanguageSection>
